有意思的题目

- [x] 1、

```js
var a,b;
(function(){
	alert(a);
	alert(b);
	var a=b=3;
alert(a);
	alert(b);
})();
alert(a);
alert(b);
// undefined，undefined，3,3，undefined，3
```

var a=b=3 时a是局部变量，而b是全局变量

- [x] 2、

https://www.nowcoder.com/test/question/done?tid=44437198&qid=56240#summary

```js
function fn() {
	let n = 1
function add() {
   n++
   console.log(n)
}
return {
   n: n,
   add: add
}
}
let res = fn()
let res1 = fn()
res.add() // 2
res.add() // 3
console.log(res.n) // 1
res1.add() // 2
```

console.log(res.n) // 1 ？？？

res、res1是一个对象，开辟新的堆内存，它们调用add方法时，会形成各自的私有作用域，res.n找的只是res对应堆内存中n。

fn方法返回了一个有着值为n的属性n和值为add的方法add的匿名对象，在这里，在这个匿名对象中，属性n和方法add是互不相关的，即使在闭包add中改变了变量n的值，result.n的值依然不变。

- [x] 3、

this的指向要等到代码真正执行时才能确定
同时this的值具体有以下几种情况：
1、如果有new关键字，this指向new出来的那个对象
2、call、apply调用，指向我们指定的对象
3、对象调用，如执行obj.b()，this指向obj
4、默认的，指向全局变量window(相当于执行window.fun())

5、在事件中，this指向触发这个事件的对象（特殊的是：IE中的attachEvent中的this总是指向全局对象window）

6、this总是指向函数的直接调用者

7、箭头函数没有this。箭头函数会捕获其所在上下文的this值，作为自己的this值。

```js
var obj ={a:1,b:function () {alert(this.a)}}; 
var fun =obj.b; 
fun(); // 弹出undefined
// 相当于this.fun(),this指向window，而window没有定义变量a，结果是undefined。

var obj ={a:1,b:function () {alert(this.a)}}; 
obj.b() // 弹出1
// 此时this指向obj,obj中的a为1
```

- [x] 4、

```js
// 打印出什么？
console.log(typeof (function() {console.log('Hello World!')})())
// Hello World! undefined
// 立即执行函数没有返回值，相当于返回undefined

console.log(typeof 
(function() {
	console.log('Hello World!')
	return undefined
})()
)
// Hello World! undefined
console.log(typeof 
(function() {
	console.log('Hello World!')
	return 1
})()
)
// Hello World! number
```

- [x] 5、

```js
// a的值时什么？
if(! "a" in window){
	var a = 1;
}
alert(a);
```

if中的a使用var申明，没有块级作用域，变量a提升，所以相当于：

```js
var a
if(! "a" in window){
a = 1;
}
alert(a);
```

判断`！`运算符与`in`运算符的优先级

```js
let obj = {a: 1}
a in obj  // false
'a' in obj  // true
'b' in obj  // false
!('b' in obj) // true
!'b' in obj // false
// 所以！优先级高于in
// 逻辑非优先级17、in优先级12
```

综上，没有进入if判断，a仅申明没赋值，值为undefined

- [x] 6、

  ```js
  var m= 1, j = k = 0; 
  function add(n) { 
      return n = n+1; 
  } 
  y = add(m); 
  function add(n) { 
      return n = n + 3; 
  } 
  z = add(m); 
  // y=4,z=4
  // 
  ```

  js中没有函数重载的概念，由于函数声明提升，解析到同名函数，后面的add函数会覆盖第一个add函数，所以z和y的值都相同





