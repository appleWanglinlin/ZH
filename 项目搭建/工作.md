#### **2021-7-20**

- vetur--VS Code的Vue工具。

  [jsconfig.json](https://vuejs.github.io/vetur/guide/setup.html#path-mapping)

  ```json
  // 使在vscode编辑器中,输入@/xxx时，有文件的路径提示
  {
      "compilerOptions": {
          "baseUrl": "./",
          "paths": {
           "@/*": ["src/*"]
  	}
  },
  	"exclude": ["node_modules", "dist"]
  }
  ```

- 新增【店铺所在】需求

#### 2021-7-21

- 【店铺所在】权限bug

- 独立站对接--网站装修

- 培训系统侧边栏缩进bug

- [browserslist](https://cli.vuejs.org/zh/guide/browser-compatibility.html#browserslist)

  你会发现有 `package.json` 文件里的 `browserslist` 字段 (或一个单独的 `.browserslistrc` 文件)，指定了项目的目标浏览器的范围。这个值会被 [@babel/preset-env](https://new.babeljs.io/docs/en/next/babel-preset-env.html) 和 [Autoprefixer](https://github.com/postcss/autoprefixer) 用来确定需要转译的 JavaScript 特性和需要添加的 CSS 浏览器前缀。

  现在查阅[这里](https://github.com/ai/browserslist)了解如何指定浏览器范围。

- [ESLint](https://cli.vuejs.org/zh/config/#eslint) 

  ESLint 可以通过 `.eslintrc` 或 `package.json` 中的 `eslintConfig` 字段来配置。

  更多细节可查阅 [@vue/cli-plugin-eslint](https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-eslint)。

#### 2021-7-22

- [__dirname](http://nodejs.cn/api/modules.html#modules_dirname)
- [path.join()](http://nodejs.cn/api/path.html#path_path_join_paths)

#### 2021-7-23

- [scoped-css](https://vue-loader.vuejs.org/zh/guide/scoped-css.html#scoped-css)

#### 2021-7-24

- vuex

  - [promise](https://vuex.vuejs.org/zh/installation.html#promise)

    Vuex 依赖 [Promise (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises)。如果你支持的浏览器并没有实现 Promise (比如 IE)，那么你可以使用一个 polyfill 的库，例如 [es6-promise (opens new window)](https://github.com/stefanpenner/es6-promise)。

    你可以通过 CDN 将其引入：

    ```html
    <script src="https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.js"></script>
    ```

    然后 `window.Promise` 会自动可用。

- [store](https://vuex.vuejs.org/zh/guide/) 

  - 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地**提交 (commit) mutation**。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。

  - 为了在 Vue 组件中访问 `this.$store` property，你需要为 Vue 实例提供创建好的 store。Vuex 提供了一个从根组件向所有子组件，以 `store` 选项的方式“注入”该 store 的机制：

    ```js
    new Vue({
      el: '#app',
      store: store,
    })
    ```

    通过在根实例中注册 `store` 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 `this.$store` 访问到。

  - 由于 store 中的状态是响应式的，在组件中调用 store 中的状态简单到仅需要在计算属性中返回即可。触发变化也仅仅是在组件的 methods 中提交 mutation。

- [state](https://vuex.vuejs.org/zh/guide/state.html)

  - 那么我们如何在 Vue 组件中展示状态呢？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在[计算属性 (opens new window)](https://cn.vuejs.org/guide/computed.html)中返回某个状态：

    ```js
    // 创建一个 Counter 组件
    const Counter = {
      template: `<div>{{ count }}</div>`,
      computed: {
        count () {
          return this.$store.state.count
        }
      }
    }
    ```

    每当 `store.state.count` 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。

  - mapState辅助函数

    当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 `mapState` 辅助函数帮助我们生成计算属性，让你少按几次键：

    ```js
    // 在单独构建的版本中辅助函数为 Vuex.mapState
    import { mapState } from 'vuex'
    
    export default {
      // ...
      computed: mapState({
        // 箭头函数可使代码更简练
        count: state => state.count,
    
        // 传字符串参数 'count' 等同于 `state => state.count`
        countAlias: 'count',
    
        // 为了能够使用 `this` 获取局部状态，必须使用常规函数
        countPlusLocalState (state) {
          return state.count + this.localCount
        }
      })
    }
    ```

    当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 `mapState` 传一个字符串数组。

    ```js
    computed: mapState([
      // 映射 this.count 为 store.state.count
      'count'
    ])
    ```

  - 对象展开运算符

    `mapState` 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 `computed` 属性。但是自从有了[对象展开运算符 (opens new window)](https://github.com/tc39/proposal-object-rest-spread)，我们可以极大地简化写法：

    ```js
    computed: {
      localComputed () { /* ... */ },
      // 使用对象展开运算符将此对象混入到外部对象中
      ...mapState({
        // ...
      })
    }
    ```

- src/assets目录是干啥的

- 控制台vue工具，查看vuex的数据

2

3





